[
  "\nvoid print_vector(std::vector<int>& v) {\n\tfor (auto x : v) {\n\t\tstd::cout << x << \" \";\n\t}\n\tstd::cout << std::endl;\n\tstd::cout << \"-----------------\" << std::endl;\n}\n",
  "\nint n = v.size();\nfor (int i = 0; i < n; i++) {\n\twhile (v[i] > 0 && v[i] <= n && v[i] != v[v[i]-1]) {\n\t\tstd::swap(v[i], v[v[i]-1]);\n\t}\n}\n",
  "\nint char_code = int(input[i] - 'a');\nif (prev_char[char_code] == -1 || prev_char[char_code] < prev_pointer) {\n\tcurr_len++;\n\tmax_len = std::max(max_len, curr_len);\n\tprev_char[char_code] = i;\n}\n",
  "\nelse if (prev_char[char_code] >= prev_pointer) {\n\tcurr_len = i - prev_char[char_code];\n\tprev_pointer = prev_char[char_code] + 1;\n\tmax_len = std::max(max_len, curr_len);\n\tprev_char[char_code] = i;\n}\n",
  "\nfor (int j = n-1; j >= 0; j--) {\n\tfor (int i = n-1; i >= j; i--) {\n\t\tif (dp[j][i] == 1) {\n\t\t\tif (i - j + 1 > max_len) {\n\t\t\t\trange = {j, i};\n\t\t\t\tmax_len = i - j + 1;\n\t\t\t}\n\t\t}\n\t}\n}\n",
  "\ndef export(sqlQuery):\n\tdb = connect_db()\n\tprint('Connected to the DB')\n\tdata_array = pd.read_sql(sqlQuery, con=db)\n\tprint('Data fetching complete')\n\treturn data_array\n",
  "\ndef get_job_name_id(name):\n\tif name is None:\n\t\tname = 'unnamed'\n\tuuid = str(uuid.uuid4())\n\ttoday = (datetime.today() + timedelta(hours=5.5)).strftime('%Y-%m-%d')\n\tjob_name = name + '-' + today + '-' + uuid[:8]\n\treturn (job_name, uuid)\n",
  "\ndef initialise_dynamic_map(self):\n\tself.dynamic_function_map = {\n\t\t'promotion': self.get_promotion,\n\t\t'reviews': self.get_reviews\n\t}\n",
  "\ncat_strs = []\nfor cat in cat_items:\n\tcat_str = cat.text.strip()\n\tcat_strs.append(cat_str)\nextracted_category = \" > \".join(cat_strs)\n",
  "\nproduct_spec_dict = self.get_product_spec_dict(html_element)\nparameters = ['Brand', 'Manufacturer']\nfor param in parameters:\n\tif param in product_spec_dict.keys():\n\t\textracted_mfgr = product_spec_dict[param]\n\t\tbreak\n",
  "\nmfgr_raw_can = canonicalize(mfgr_raw)\nentry = session.query(Mfgr).filter_by(mfgrValue=mfgr_raw_can).first()\nif entry is not None:\n\tm1 = Mfgr(mfgrCanonical_id=entry.id, mfgrValue=mfgr_raw, comment='')\n\tsession.add_all([m1])\n\tsession.commit()\n\treturn m1\n",
  "\nm2 = Mfgr(mfgrValue=mfgr_raw_can, comment='')\nsession.add_all([m2])\nsession.commit()\nm2.mfgrCanonical_id = m2.id\nsession.commit()\n",
  "\n__tablename__ = \"ut_availability\"\nid = Column(Integer, primary_key=True)\nsite_id = Column(Integer)\nstringValue = Column(String(255))\nmapper_id = Column(Integer, default=-5)\nmap_status = Column(Integer, nullable=True)\n",
  "\ndef get_delivery_time_days_upto(self, html_element):\n\tdelivery_str = self.get_delivery_time_raw(html_element)\n\tdelivery_time_days_upto = self.get_delivery_str_to_int(delivery_str)[1]\n\treturn delivery_time_days_upto\n\n",
  "\nawait self.page.wait_for_timeout(1000)\nawait self.pre_action()\nawait self.set_location()\nawait self.page.wait_for_timeout(1000)\nawait self.page.mouse.wheel(delta_x=0, delta_y=5000)\nawait self.page.wait_for_timeout(3000)\n",
  "\nstd::vector<std::string> inputs = {\"bb\", \"bbbbsd\", \"ababdd\", \"cbbd\"};\nfor (string s : inputs) {\n\tstd::string ans = longestPalindrome(s);\n\tcout << \"Input: \" << s << endl;\n\tstd::cout << \"Result: \" << ans << std::endl;\n\n}\n",
  "\nvoid print2DArray (std::vector<std::vector<int>>& array) {\n\tfor (auto row : array) {\n\t\tfor (auto e : row) {\n\t\t\tcout << e << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n",
  "\nint char_code = int(input[i] - 'a');\nif (prev_char[char_code] == -1 || prev_char[char_code] < prev_pointer) {\n\tcurr_len++;\n\tmax_len = std::max(max_len, curr_len);\n\tprev_char[char_code] = i;\n}\n",
  "\nelse if (prev_char[char_code] >= prev_pointer) {\n\tcurr_len = i - prev_char[char_code];\n\tprev_pointer = prev_char[char_code] + 1;\n\tmax_len = std::max(max_len, curr_len);\n\tprev_char[char_code] = i;\n}\n",
  "\nvoid search(std::vector<int>& v, int k, int n) {\n\tif (k == n) {\n\t\tprint_vector(v);\n\t\treturn;\n\t}\n\tsearch(v, k+1, n);\n\tv.push_back(k);\n\tsearch(v, k+1, n);\n\tv.pop_back();\n}\n",
  "\nint main () {\n\tstd::vector<int> v;\n\tint n = 5;\n\tfor (int b = 0; b < (1 << n); b++) {\n\t\tstd::vector v;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (b & (1 << i)) v.push_back(i);\n\t\t}\n\t\tprint_vector(v);\n\t}\n}\n",
  "\nvoid search(std::vector<int>& permuation, std::vector<int>& choosen, int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (choosen[i]) continue;\n\t\tchoosen[i] = true;\n\t\tpermuation.push_back(i);\n\t\tsearch(permuation, choosen, n);\n\t\tpermuation.pop_back();\n\t\tchoosen[i] = false;\n\t}\n}\n",
  "\nvisited[x] = true;\ndistance[x] = 0;\nq.push(x);\nwhile (!q.empty()) {\n\tint s = q.front(); q.pop();\n\t// process node s\n\tfor (auto u : adj[s]) {\n\t\tif (visited[u]) continue;\n\t\tvisited[u] = true;\n\t\tdistance[u] = distance[s]+1;\n\t\tq.push(u);\n\t}\n}\n",
  "\nvoid dfs(int s) {\n\tif (visited[s]) return;\n\tvisited[s] = true;\n\t// process node s\n\tfor (auto u: adj[s]) {\n\t\tdfs(u);\n\t}\n}\n",
  "\nfor (int i = 1; i <= n; i++) distance[i] = INF;\n\tdistance[x] = 0;\n\tfor (int i = 1; i <= n-1; i++) {\n\tfor (auto e : edges) {\n\t\tint a, b, w;\n\t\ttie(a, b, w) = e;\n\t\tdistance[b] = min(distance[b], distance[a]+w);\n\t}\n}\n",
  "\nfor (int i = 1; i <= n; i++) distance[i] = INF;\ndistance[x] = 0;\nq.push({0,x});\n",
  "\nwhile (!q.empty()) {\n\tint a = q.top().second; q.pop();\n\tif (processed[a]) continue;\n\tprocessed[a] = true;\n\tfor (auto u : adj[a]) {\n\t\tint b = u.first, w = u.second;\n\t\tif (distance[a]+w < distance[b]) {\n\t\tdistance[b] = distance[a]+w;\n\t\tq.push({-distance[b],b});\n\t\t}\n\t}\n}\n",
  "\nfor (int i = 1; i <= n; i++) {\n\tfor (int j = 1; j <= n; j++) {\n\t\tif (i == j) distance[i][j] = 0;\n\t\telse if (adj[i][j]) distance[i][j] = adj[i][j];\n\t\telse distance[i][j] = INF;\n\t}\n}\n",
  "\nfor (int k = 1; k <= n; k++) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tdistance[i][j] = min(distance[i][j],\n\t\t\tdistance[i][k]+distance[k][j]);\n\t\t}\n\t}\n}\n",
  "\nvoid dfs(int s, int e) {\n\tcount[s] = 1;\n\tfor (auto u : adj[s]) {\n\t\tif (u == e) continue;\n\t\tdfs(u, s);\n\t\tcount[s] += count[u];\n\t}\n}\n"
]