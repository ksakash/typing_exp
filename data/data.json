[
  "\nvoid print_vector(std::vector<int>& v) {\n\tfor (auto x : v) {\n\t\tstd::cout << x << \" \";\n\t}\n\tstd::cout << std::endl;\n\tstd::cout << \"-----------------\" << std::endl;\n}\n",
  "\nvoid search(std::vector<int>& v, int k, int n) {\n\tif (k == n) {\n\t\tprint_vector(v);\n\t\treturn;\n\t}\n\tsearch(v, k+1, n);\n\tv.push_back(k);\n\tsearch(v, k+1, n);\n\tv.pop_back();\n}\n",
  "\nint main () {\n\tstd::vector<int> v;\n\tint n = 5;\n\tfor (int b = 0; b < (1 << n); b++) {\n\t\tstd::vector v;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (b & (1 << i)) v.push_back(i);\n\t\t}\n\t\tprint_vector(v);\n\t}\n}\n",
  "\nvoid search(std::vector<int>& permuation, std::vector<int>& choosen, int n) {\n\tif (permuation.size() == n) {\n\t\tprint_vector(permuation);\n\t\treturn;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tif (choosen[i]) continue;\n\t\tchoosen[i] = true;\n\t\tpermuation.push_back(i);\n\t\tsearch(permuation, choosen, n);\n\t\tpermuation.pop_back();\n\t\tchoosen[i] = false;\n\t}\n}\n",
  "\nvisited[x] = true;\ndistance[x] = 0;\nq.push(x);\nwhile (!q.empty()) {\n\tint s = q.front(); q.pop();\n\t// process node s\n\tfor (auto u : adj[s]) {\n\t\tif (visited[u]) continue;\n\t\tvisited[u] = true;\n\t\tdistance[u] = distance[s]+1;\n\t\tq.push(u);\n\t}\n}\n",
  "\nvoid dfs(int s) {\n\tif (visited[s]) return;\n\tvisited[s] = true;\n\t// process node s\n\tfor (auto u: adj[s]) {\n\t\tdfs(u);\n\t}\n}\n",
  "\nfor (int i = 1; i <= n; i++) distance[i] = INF;\n\tdistance[x] = 0;\n\tfor (int i = 1; i <= n-1; i++) {\n\tfor (auto e : edges) {\n\t\tint a, b, w;\n\t\ttie(a, b, w) = e;\n\t\tdistance[b] = min(distance[b], distance[a]+w);\n\t}\n}\n",
  "\nfor (int i = 1; i <= n; i++) distance[i] = INF;\ndistance[x] = 0;\nq.push({0,x});\nwhile (!q.empty()) {\n\tint a = q.top().second; q.pop();\n\tif (processed[a]) continue;\n\tprocessed[a] = true;\n\tfor (auto u : adj[a]) {\n\t\tint b = u.first, w = u.second;\n\t\tif (distance[a]+w < distance[b]) {\n\t\tdistance[b] = distance[a]+w;\n\t\tq.push({-distance[b],b});\n\t\t}\n\t}\n}\n",
  "\nfor (int i = 1; i <= n; i++) {\n\tfor (int j = 1; j <= n; j++) {\n\t\tif (i == j) distance[i][j] = 0;\n\t\telse if (adj[i][j]) distance[i][j] = adj[i][j];\n\t\telse distance[i][j] = INF;\n\t}\n}\n\nfor (int k = 1; k <= n; k++) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tdistance[i][j] = min(distance[i][j],\n\t\t\tdistance[i][k]+distance[k][j]);\n\t\t}\n\t}\n}\n",
  "\nvoid dfs(int s, int e) {\n\tcount[s] = 1;\n\tfor (auto u : adj[s]) {\n\t\tif (u == e) continue;\n\t\tdfs(u, s);\n\t\tcount[s] += count[u];\n\t}\n}\n"
]
